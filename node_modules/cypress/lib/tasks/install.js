"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n          ", " Warning: Forcing a binary version different than the default.\n\n            The CLI expected to install version: ", "\n\n            Instead we will install version: ", "\n\n            These versions may not work properly together.\n        "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n      Cypress ", " is installed in ", "\n      "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n    Failed to access ", ":\n\n    ", "\n    "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n        ", " Overriding Cypress cache directory to: ", "\n\n              Previous installs of Cypress may not be found.\n      "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n        ", " Skipping binary installation: Environment variable CYPRESS_INSTALL_BINARY = 0."]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n      ", " Warning: It looks like you've installed Cypress globally.\n\n        This will work, but it's not recommended.\n\n        The recommended way to install Cypress is as a devDependency per project.\n\n        You should probably run these commands:\n\n        - ", "\n        - ", "\n    "], ["\n      ", " Warning: It looks like you\\'ve installed Cypress globally.\n\n        This will work, but it'\\s not recommended.\n\n        The recommended way to install Cypress is as a devDependency per project.\n\n        You should probably run these commands:\n\n        - ", "\n        - ", "\n    "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n      Skipping installation:\n\n        Pass the ", " option if you'd like to reinstall anyway.\n    "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _wrapNativeSuper(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _inherits(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_typeof(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _ = require('lodash');

var os = require('os');

var url = require('url');

var path = require('path');

var chalk = require('chalk');

var debug = require('debug')('cypress:cli');

var Listr = require('listr');

var verbose = require('@cypress/listr-verbose-renderer');

var Promise = require('bluebird');

var logSymbols = require('log-symbols');

var _require = require('common-tags'),
    stripIndent = _require.stripIndent;

var fs = require('../fs');

var download = require('./download');

var util = require('../util');

var state = require('./state');

var unzip = require('./unzip');

var logger = require('../logger');

var _require2 = require('../errors'),
    throwFormErrorText = _require2.throwFormErrorText,
    errors = _require2.errors;

var getNpmArgv = function getNpmArgv() {
  var json = process.env.npm_config_argv;

  if (!json) {
    return;
  }

  debug('found npm argv json %o', json);

  try {
    return JSON.parse(json).original || [];
  } catch (e) {
    return [];
  }
}; // attempt to discover the version specifier used to install Cypress
// for example: "^5.0.0", "https://cdn.cypress.io/...", ...


var getVersionSpecifier = function getVersionSpecifier() {
  var startDir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : path.resolve(__dirname, '../..');
  var argv = getNpmArgv();

  if (argv) {
    var tgz = _.find(argv, function (t) {
      return t.endsWith('cypress.tgz');
    });

    if (tgz) {
      return tgz;
    }
  }

  var getVersionSpecifierFromPkg = function getVersionSpecifierFromPkg(dir) {
    debug('looking for versionSpecifier %o', {
      dir: dir
    });

    var tryParent = function tryParent() {
      var parentPath = path.resolve(dir, '..');

      if (parentPath === dir) {
        debug('reached FS root with no versionSpecifier found');
        return;
      }

      return getVersionSpecifierFromPkg(parentPath);
    };

    return fs.readJSON(path.join(dir, 'package.json'))["catch"](function () {
      return {};
    }).then(function (pkg) {
      var specifier = _.chain(['dependencies', 'devDependencies', 'optionalDependencies']).map(function (prop) {
        return _.get(pkg, "".concat(prop, ".cypress"));
      }).compact().first().value();

      return specifier || tryParent();
    });
  }; // recurse through parent directories until package.json with `cypress` is found


  return getVersionSpecifierFromPkg(startDir).then(function (versionSpecifier) {
    debug('finished looking for versionSpecifier', {
      versionSpecifier: versionSpecifier
    });
    return versionSpecifier;
  });
};

var betaNpmUrlRe = /*#__PURE__*/_wrapRegExp(/^\/beta\/npm\/([\.0-9]+)\/([\0-\.0-\uFFFF]+)\/cypress\.tgz$/, {
  version: 1,
  artifactSlug: 2
}); // convert a prerelease NPM package .tgz URL to the corresponding binary .zip URL


var getBinaryUrlFromPrereleaseNpmUrl = function getBinaryUrlFromPrereleaseNpmUrl(npmUrl) {
  var parsed;

  try {
    parsed = url.parse(npmUrl);
  } catch (e) {
    return;
  }

  var matches = betaNpmUrlRe.exec(parsed.pathname);

  if (parsed.hostname !== 'cdn.cypress.io' || !matches) {
    return;
  }

  var _matches$groups = matches.groups,
      version = _matches$groups.version,
      artifactSlug = _matches$groups.artifactSlug;
  parsed.pathname = "/beta/binary/".concat(version, "/").concat(os.platform(), "-").concat(os.arch(), "/").concat(artifactSlug, "/cypress.zip");
  return parsed.format();
};

var alreadyInstalledMsg = function alreadyInstalledMsg() {
  if (!util.isPostInstall()) {
    logger.log(stripIndent(_templateObject(), chalk.yellow('--force')));
  }
};

var displayCompletionMsg = function displayCompletionMsg() {
  // check here to see if we are globally installed
  if (util.isInstalledGlobally()) {
    // if we are display a warning
    logger.log();
    logger.warn(stripIndent(_templateObject2(), logSymbols.warning, chalk.cyan('npm uninstall -g cypress'), chalk.cyan('npm install --save-dev cypress')));
    return;
  }

  logger.log();
  logger.log('You can now open Cypress by running:', chalk.cyan(path.join('node_modules', '.bin', 'cypress'), 'open'));
  logger.log();
  logger.log(chalk.grey('https://on.cypress.io/installing-cypress'));
  logger.log();
};

var downloadAndUnzip = function downloadAndUnzip(_ref) {
  var version = _ref.version,
      installDir = _ref.installDir,
      downloadDir = _ref.downloadDir;
  var progress = {
    throttle: 100,
    onProgress: null
  };
  var downloadDestination = path.join(downloadDir, 'cypress.zip');
  var rendererOptions = getRendererOptions(); // let the user know what version of cypress we're downloading!

  logger.log("Installing Cypress ".concat(chalk.gray("(version: ".concat(version, ")"))));
  logger.log();
  var tasks = new Listr([{
    title: util.titleize('Downloading Cypress'),
    task: function task(ctx, _task) {
      // as our download progresses indicate the status
      progress.onProgress = progessify(_task, 'Downloading Cypress');
      return download.start({
        version: version,
        downloadDestination: downloadDestination,
        progress: progress
      }).then(function (redirectVersion) {
        if (redirectVersion) version = redirectVersion;
        debug("finished downloading file: ".concat(downloadDestination));
      }).then(function () {
        // save the download destination for unzipping
        util.setTaskTitle(_task, util.titleize(chalk.green('Downloaded Cypress')), rendererOptions.renderer);
      });
    }
  }, unzipTask({
    progress: progress,
    zipFilePath: downloadDestination,
    installDir: installDir,
    rendererOptions: rendererOptions
  }), {
    title: util.titleize('Finishing Installation'),
    task: function task(ctx, _task2) {
      var cleanup = function cleanup() {
        debug('removing zip file %s', downloadDestination);
        return fs.removeAsync(downloadDestination);
      };

      return cleanup().then(function () {
        debug('finished installation in', installDir);
        util.setTaskTitle(_task2, util.titleize(chalk.green('Finished Installation'), chalk.gray(installDir)), rendererOptions.renderer);
      });
    }
  }], rendererOptions); // start the tasks!

  return Promise.resolve(tasks.run());
};

var start = function start() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // handle deprecated / removed
  if (util.getEnv('CYPRESS_BINARY_VERSION')) {
    return throwFormErrorText(errors.removed.CYPRESS_BINARY_VERSION)();
  }

  if (util.getEnv('CYPRESS_SKIP_BINARY_INSTALL')) {
    return throwFormErrorText(errors.removed.CYPRESS_SKIP_BINARY_INSTALL)();
  }

  debug('installing with options %j', options);

  _.defaults(options, {
    force: false
  });

  var pkgVersion = util.pkgVersion();
  var needVersion = pkgVersion;
  var binaryUrlOverride;
  debug('version in package.json is', needVersion); // let this environment variable reset the binary version we need

  if (util.getEnv('CYPRESS_INSTALL_BINARY')) {
    // because passed file paths are often double quoted
    // and might have extra whitespace around, be robust and trim the string
    var trimAndRemoveDoubleQuotes = true;
    var envVarVersion = util.getEnv('CYPRESS_INSTALL_BINARY', trimAndRemoveDoubleQuotes);
    debug('using environment variable CYPRESS_INSTALL_BINARY "%s"', envVarVersion);

    if (envVarVersion === '0') {
      debug('environment variable CYPRESS_INSTALL_BINARY = 0, skipping install');
      logger.log(stripIndent(_templateObject3(), chalk.yellow('Note:')));
      logger.log();
      return Promise.resolve();
    }

    binaryUrlOverride = envVarVersion;
  }

  if (util.getEnv('CYPRESS_CACHE_FOLDER')) {
    var envCache = util.getEnv('CYPRESS_CACHE_FOLDER');
    logger.log(stripIndent(_templateObject4(), chalk.yellow('Note:'), chalk.cyan(envCache)));
    logger.log();
  }

  var installDir = state.getVersionDir(pkgVersion);
  var cacheDir = state.getCacheDir();
  var binaryDir = state.getBinaryDir(pkgVersion);
  return fs.ensureDirAsync(cacheDir)["catch"]({
    code: 'EACCES'
  }, function (err) {
    return throwFormErrorText(errors.invalidCacheDirectory)(stripIndent(_templateObject5(), chalk.cyan(cacheDir), err.message));
  }).then(function () {
    return Promise.all([state.getBinaryPkgVersionAsync(binaryDir), getVersionSpecifier()]);
  }).then(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        binaryVersion = _ref3[0],
        versionSpecifier = _ref3[1];

    if (!binaryUrlOverride && versionSpecifier) {
      var computedBinaryUrl = getBinaryUrlFromPrereleaseNpmUrl(versionSpecifier);

      if (computedBinaryUrl) {
        debug('computed binary url from version specifier %o', {
          computedBinaryUrl: computedBinaryUrl,
          needVersion: needVersion
        });
        binaryUrlOverride = computedBinaryUrl;
      }
    }

    needVersion = binaryUrlOverride || needVersion;
    debug('installed version is', binaryVersion, 'version needed is', needVersion);

    if (!binaryVersion) {
      debug('no binary installed under cli version');
      return true;
    }

    logger.log();
    logger.log(stripIndent(_templateObject6(), chalk.green(binaryVersion), chalk.cyan(installDir)));
    logger.log();

    if (options.force) {
      debug('performing force install over existing binary');
      return true;
    }

    if (binaryVersion === needVersion || !util.isSemver(needVersion)) {
      // our version matches, tell the user this is a noop
      alreadyInstalledMsg();
      return false;
    }

    return true;
  }).then(function (shouldInstall) {
    // noop if we've been told not to download
    if (!shouldInstall) {
      debug('Not downloading or installing binary');
      return;
    }

    if (needVersion !== pkgVersion) {
      logger.log(chalk.yellow(stripIndent(_templateObject7(), logSymbols.warning, chalk.green(pkgVersion), chalk.green(needVersion))));
      logger.log();
    } // see if version supplied is a path to a binary


    return fs.pathExistsAsync(needVersion).then(function (exists) {
      if (exists) {
        return path.extname(needVersion) === '.zip' ? needVersion : false;
      }

      var possibleFile = util.formAbsolutePath(needVersion);
      debug('checking local file', possibleFile, 'cwd', process.cwd());
      return fs.pathExistsAsync(possibleFile).then(function (exists) {
        // if this exists return the path to it
        // else false
        if (exists && path.extname(possibleFile) === '.zip') {
          return possibleFile;
        }

        return false;
      });
    }).then(function (pathToLocalFile) {
      if (pathToLocalFile) {
        var absolutePath = path.resolve(needVersion);
        debug('found local file at', absolutePath);
        debug('skipping download');
        var rendererOptions = getRendererOptions();
        return new Listr([unzipTask({
          progress: {
            throttle: 100,
            onProgress: null
          },
          zipFilePath: absolutePath,
          installDir: installDir,
          rendererOptions: rendererOptions
        })], rendererOptions).run();
      }

      if (options.force) {
        debug('Cypress already installed at', installDir);
        debug('but the installation was forced');
      }

      debug('preparing to download and unzip version ', needVersion, 'to path', installDir);
      var downloadDir = os.tmpdir();
      return downloadAndUnzip({
        version: needVersion,
        installDir: installDir,
        downloadDir: downloadDir
      });
    }) // delay 1 sec for UX, unless we are testing
    .then(function () {
      return Promise.delay(1000);
    }).then(displayCompletionMsg);
  });
};

module.exports = {
  start: start,
  _getVersionSpecifier: getVersionSpecifier,
  _getBinaryUrlFromPrereleaseNpmUrl: getBinaryUrlFromPrereleaseNpmUrl
};

var unzipTask = function unzipTask(_ref4) {
  var zipFilePath = _ref4.zipFilePath,
      installDir = _ref4.installDir,
      progress = _ref4.progress,
      rendererOptions = _ref4.rendererOptions;
  return {
    title: util.titleize('Unzipping Cypress'),
    task: function task(ctx, _task3) {
      // as our unzip progresses indicate the status
      progress.onProgress = progessify(_task3, 'Unzipping Cypress');
      return unzip.start({
        zipFilePath: zipFilePath,
        installDir: installDir,
        progress: progress
      }).then(function () {
        util.setTaskTitle(_task3, util.titleize(chalk.green('Unzipped Cypress')), rendererOptions.renderer);
      });
    }
  };
};

var progessify = function progessify(task, title) {
  // return higher order function
  return function (percentComplete, remaining) {
    percentComplete = chalk.white(" ".concat(percentComplete, "%")); // pluralize seconds remaining

    remaining = chalk.gray("".concat(remaining, "s"));
    util.setTaskTitle(task, util.titleize(title, percentComplete, remaining), getRendererOptions().renderer);
  };
}; // if we are running in CI then use
// the verbose renderer else use
// the default


var getRendererOptions = function getRendererOptions() {
  var renderer = util.isCi() ? verbose : 'default';

  if (logger.logLevel() === 'silent') {
    renderer = 'silent';
  }

  return {
    renderer: renderer
  };
};