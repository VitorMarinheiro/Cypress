"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var state = require('./state');

var logger = require('../logger');

var fs = require('../fs');

var util = require('../util');

var _require = require('path'),
    join = _require.join;

var Table = require('cli-table3');

var moment = require('moment');

var chalk = require('chalk');

var _ = require('lodash');

var getFolderSize = require('./get-folder-size');

var Bluebird = require('bluebird'); // output colors for the table


var colors = {
  titles: chalk.white,
  dates: chalk.cyan,
  values: chalk.green,
  size: chalk.gray
};

var logCachePath = function logCachePath() {
  logger.always(state.getCacheDir());
  return undefined;
};

var clear = function clear() {
  return fs.removeAsync(state.getCacheDir());
};

var prune = function prune() {
  var cacheDir = state.getCacheDir();
  var currentVersion = util.pkgVersion();
  var deletedBinary = false;
  return fs.readdirAsync(cacheDir).then(function (versions) {
    return Bluebird.all(versions.map(function (version) {
      if (version !== currentVersion) {
        deletedBinary = true;
        var versionDir = join(cacheDir, version);
        return fs.removeAsync(versionDir);
      }
    }));
  }).then(function () {
    if (deletedBinary) {
      logger.always("Deleted all binary caches except for the ".concat(currentVersion, " binary cache."));
    } else {
      logger.always("No binary caches found to prune.");
    }
  })["catch"]({
    code: 'ENOENT'
  }, function () {
    logger.always("No Cypress cache was found at ".concat(cacheDir, ". Nothing to prune."));
  });
};

var fileSizeInMB = function fileSizeInMB(size) {
  return "".concat((size / 1024 / 1024).toFixed(1), "MB");
};
/**
 * Collects all cached versions, finds when each was used
 * and prints a table with results to the terminal
 */


var list = function list(showSize) {
  return getCachedVersions(showSize).then(function (binaries) {
    var head = [colors.titles('version'), colors.titles('last used')];

    if (showSize) {
      head.push(colors.titles('size'));
    }

    var table = new Table({
      head: head
    });
    binaries.forEach(function (binary) {
      var versionString = colors.values(binary.version);
      var lastUsed = binary.accessed ? colors.dates(binary.accessed) : 'unknown';
      var row = [versionString, lastUsed];

      if (showSize) {
        var size = colors.size(fileSizeInMB(binary.size));
        row.push(size);
      }

      return table.push(row);
    });
    logger.always(table.toString());
  });
};

var getCachedVersions = function getCachedVersions(showSize) {
  var cacheDir = state.getCacheDir();
  return fs.readdirAsync(cacheDir).filter(util.isSemver).map(function (version) {
    return {
      version: version,
      folderPath: join(cacheDir, version)
    };
  }).mapSeries(function (binary) {
    // last access time on the folder is different from last access time
    // on the Cypress binary
    var binaryDir = state.getBinaryDir(binary.version);
    var executable = state.getPathToExecutable(binaryDir);
    return fs.statAsync(executable).then(function (stat) {
      var lastAccessedTime = _.get(stat, 'atime');

      if (!lastAccessedTime) {
        // the test runner has never been opened
        // or could be a test simulating missing timestamp
        return binary;
      }

      var accessed = moment(lastAccessedTime).fromNow();
      binary.accessed = accessed;
      return binary;
    }, function (e) {
      // could not find the binary or gets its stats
      return binary;
    });
  }).mapSeries(function (binary) {
    if (showSize) {
      var binaryDir = state.getBinaryDir(binary.version);
      return getFolderSize(binaryDir).then(function (size) {
        return _objectSpread(_objectSpread({}, binary), {}, {
          size: size
        });
      });
    }

    return binary;
  });
};

module.exports = {
  path: logCachePath,
  clear: clear,
  prune: prune,
  list: list,
  getCachedVersions: getCachedVersions
};